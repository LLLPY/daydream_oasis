
<BlogInfo id="1209" title="135.二叉树的最近公共祖先" author="白日梦想猿" pv=0 read_times=0 pre_cost_time="2分40秒" category="leetcode" tag_list="['leetcode']" create_time="2022.07.04 19:50:27" update_time="2022.07.04 20:32:43" />

```python
# -*- coding: UTF-8 -*-
'''
   *****************LLL*********************
   * @Project ：leetcode                       
   * @File    ：lll132_二叉树的最近公共祖先.py                  
   * @IDE     ：PyCharm             
   * @Author  ：LLL                         
   * @Date    ：2022/7/4 19:50             
   *****************************************
'''

'''给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

 

示例 1：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2：


输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3：

输入：root = [1,2], p = 1, q = 2
输出：1
 

提示：

树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。
通过次数404,634提交次数585,176

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。'''


# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        # 遍历整个树，直到找到p和q为止 同时为每个节点添加一个parent属性，用来记录当前节点的父节点(根节点除外)
        self.dfs(root, p, q)

        # 分别获取p，q的父节点列表
        p_parent_li = [p]
        q_parent_li = [q]
        tmp_p, tmp_q = p, q  # 临时存储p，q的值
        root.parent = None

        # 之所以用try是因为如果p和q在一条线上，即p是q的祖先节点或者q是p的祖先节点
        # 因为深度优先遍历的条件是只要找到它们其中一个就结束，所以这样必定有一个节点
        # 没有给他赋parent属性，那么在取值的时候就会报错，此时如果报错的是p，那么q
        # 一定是p的祖先节点，反之p是q的祖先节点
        try:
            while p.parent:
                p_parent_li.append(p.parent)
                p = p.parent
        except:
            return tmp_q

        try:
            while q.parent:
                q_parent_li.append(q.parent)
                q = q.parent
        except:
            return tmp_p

        p_parent_li_len = len(p_parent_li)
        q_parent_li_len = len(q_parent_li)

        # 查找比对(根据两条列表的长度，用长的列表在短的列表中查找)
        if p_parent_li_len < q_parent_li_len:
            for i in range(p_parent_li_len):
                for j in range(q_parent_li_len):
                    if p_parent_li[i] == q_parent_li[j]:
                        return p_parent_li[i]
        else:
            for i in range(q_parent_li_len):
                for j in range(p_parent_li_len):
                    if q_parent_li[i] == p_parent_li[j]:
                        return q_parent_li[i]

    # 深度优先遍历为每一个节点添加父节点
    def dfs(self, root, p, q):
        if root == p or root == q:  # 只要找到p或者q就停止遍历
            return

        else:
            if root.left:
                root.left.parent = root
                self.dfs(root.left, p, q)  # 左子树继续遍历
            if root.right:
                root.right.parent = root
                self.dfs(root.right, p, q)  # 右子树继续遍历


if __name__ == '__main__':
    root = TreeNode(1)
    r_l = TreeNode(2)
    r_r = TreeNode(4)
    r_l_l = TreeNode(3)
    root.left = r_l
    root.right = r_r
    r_l.left = r_l_l
    print(Solution().lowestCommonAncestor(root, r_l_l, r_l).val)

```
