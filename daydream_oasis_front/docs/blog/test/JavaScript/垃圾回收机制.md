
<BlogInfo title="垃圾回收机制" author="夏哲哲" pv=0 read_times=0 pre_cost_time=137 category="JavaScript" tag_list="['存储泄漏', '内存管理', '性能']" create_time="2022.07.28 16:37:19.833511" update_time="2022.07.28 16:37:19" />

^^^^^^^^^
<p><span style="font-size:22pt"><span style="font-family:等线"><span style="color:black"><strong>垃圾回收</strong></span></span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;JS是使用垃圾回收的语言，执行环境负责在代码执行时管理内存。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;在C和C++等语言中，跟踪内存使用是个负担。而JS会通过自动内存管理实现内存分配和闲置资源回收。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;基本思路：确定哪个变量不会再使用，然后释放它占用的内存。过程是周期性的。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;标记未使用变量的方法：标记清理 和 引用计数。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">1.标记清理<br />
&nbsp; #JS最常用的。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp; 垃圾回收程序运行时，会标记内存中存储的所有变量。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;然后，它会将使用在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;再被加上标记的变量就是待删除的了。（任何在上下文中的变量都访问不到他们了）</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp; 随后，垃圾回收程序做一次内存清理，销毁带标记的所有值并回收他们的内存。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">2.引用计数</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;对每一个值都记录它被引用的次数。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;被赋值给另一个变量，引用数加一；被其他值给覆盖，减一。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;引用数为0时，说明没办法再访问了，收回。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;但 循环引用 会导致不能回收。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">如：</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">function problem() {</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;let objectA = new Object();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;let objectB = new Object();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;objectA.someOtherObject = objectB;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;objectB.anotherObject = objectA;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">}</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">//objectA和objectB通过各自的相互引用，导致在函数结束后，引用数还是2。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">//若函数多次调用，会导致大量内存不能释放。</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">16:04 2022/07/26</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p><span style="font-size:22pt"><span style="font-family:等线"><span style="color:black"><strong>性能</strong></span></span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">收集垃圾的时间调度很重要，在内存有限的移动设备上，可能会明显拖慢渲染的速度和帧速率。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">要在写代码时做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">现代的垃圾回收程序会基于对JS运行时环境的探测决定何时运行。根据已分配对象的大小和数量来判断的。</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p><span style="font-size:22pt"><span style="font-family:等线"><span style="color:black"><strong>内存管理</strong></span></span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">分配给浏览器的内存通常比分配给桌面软件的要少很多。这是出于安全考虑，为避免大量JS的网页耗尽系统内存而导致操作系统崩溃。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">影响变量分配、调用栈、一个线程中执行的语句数量。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">内存占用越少，页面性能越好。</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">如果数据不再必要，设置为null，从而释放其引用。（解除引用，最适用于全局变量和全局对象的属性，而局部变量在超出作用域后会被自动解除引用）</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">但并不会导致相关内存被回收，而是在下次垃圾回收时会被回收。</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">const、let声明可以提升性能。</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">V8 JavaScript引擎，将解释后的JS代码编译为实际的机器码时会利用&lsquo;隐藏类&rsquo;。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">能共享相同隐藏类的对象 性能更好。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">要避免&ldquo;先创建再补充&rdquo;式的动态属性赋值，办法：要在构造函数里一次性声明使用属性。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">若使用delete，则会再次生成相同的隐藏类片段，（与动态添加属性导致的后果一样）办法：把不想要的属性设置为null。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">如：</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">#</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">#situation1<br />
function Article() {</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;this.title = &lsquo;xxxxx&rsquo;;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">}</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let a1 = new Article();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let a2 = new Article(); &nbsp;//这之前共享的是相同隐藏类对象</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">a2.author = &lsquo;Jake&rsquo;;&nbsp; //到这就不是了</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">#better way&gt;&gt;&gt;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">function Article(opt_author) {</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;this.title = &lsquo;xxxxx&rsquo;;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;this.author = opt_author;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">}</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let a1 = new Article();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let a2 = new Article(&lsquo;Jake&rsquo;);</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">#</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">#situation2</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">#</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">function Article() {</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;this.title = &lsquo;xxxxxx&rsquo;;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;this.author = &lsquo;Jake&rsquo;;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">}</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let a1 = new Article();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let a2 = new Article();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">delete a1.author; &nbsp;&nbsp;&nbsp;//使用的是同一个构造函数，但到这就不共享了</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">#better way&gt;&gt;&gt; &nbsp;a1.author = null;</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p><span style="font-size:22pt"><span style="font-family:等线"><span style="color:black"><strong>内存泄漏 </strong></span></span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">在内存有限的设备上，或者在函数被调用的很多次的情况下，内存泄漏就可能是给大问题。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">JS大部分的内存泄漏是由于不合理的引用导致的。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">1. 意外声明全局变量是最常见 但也最容易修复的内存泄露问题。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">如：没加变量声明关键字，在其前加上var、let、const即可。</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">2. 定时器也可能会悄悄地导致内存泄漏</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">如：定时器的回调通过闭包引用了外部变量，只要定时器一直运行，回调函数中引用的外部变量会一直占用内存。</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">3. 使用JavaScript闭包也是一样。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">如：</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let outer = function() {</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;let name = &lsquo;Jake&rsquo;;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;return function() {</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;&nbsp; return name;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp; }</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">}</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">//调用outer()会导致分配给name的内存被泄漏。代码执行后，创建了一个闭包，只要返回的函数存在就不能清理name，因为闭包一直在引用它。</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify">&nbsp;</p>

<p><span style="font-size:22pt"><span style="font-family:等线"><span style="color:black"><strong>静态分配与对象池</strong></span></span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">为了提升JS性能，就要压榨浏览器。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">减少浏览器执行垃圾回收的次数：间接触发垃圾回收的条件。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">如果能合理使用分配的内存，同时避免多余的垃圾回收，就可以保住因释放内存而损失的性能。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">而浏览器的垃圾回收程序执行是由对象更替的速度决定的。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">所以不要动态的创建对象，而是在对象池里申请对象。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">应用程序可以向这个对象池请求一个对象、设置其属性、使用他，然后操作完成后再把它还给对象池。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">如：</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">//vectorPool是已有的对象池</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let v1 = vectorPool.allocate();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let v2 = vectorPool.allocate();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let v3 = vectorPool.allocate();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">v1.x = 10;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">v1.y = 5;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">v2.x = -3;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">v2.y = -6;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">function addVector(a, b, resultant) {</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;//let resultant = new Vector();&nbsp; //这个是之前在内部创建新对象。若频繁调用，就会被发现。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp; resultant.x = a.x + b.x;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;resultant.y = a.y + b.y;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">&nbsp;&nbsp;return resultant;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">}</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">addVector(v1, v2, v3);</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">console.log([v3.x, v3.y]);&nbsp; // [7, -1]</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">vectorPool.free(v1);</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">vectorPool.free(v2);</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">vectorPool.free(v3);</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">//如果对象有属性引用了其他对象</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">//则这里也需要把这些属性设置为null。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">v1 = null;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">v2 = null;</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">v3 = null;</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">对象池若要使用某种结构维持所有对象，那使用数组。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">数组的大小要确定好，够用。因为JS的数组大小是动态可变的，引擎会删除大小为100的数组，在创建一个新的大小为200数组。如被垃圾回收看到，说不定很快跑过来收一次垃圾。</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">如：</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">#对象池创建</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let vectorList = new Array(100);</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">let vector = new Vector();</span></span></p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">vectorList.push(vector);</span></span></p>

<p style="text-align:justify">&nbsp;</p>

<p style="text-align:justify"><span style="font-size:10.5pt"><span style="font-family:等线">16:00 2022/07/27</span></span></p>

