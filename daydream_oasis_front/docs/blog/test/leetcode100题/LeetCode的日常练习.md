
<BlogInfo title="LeetCode的日常练习" author="白日梦想猿" pv=0 read_times=0 pre_cost_time=149 category="leetcode100题" tag_list="['leetcode', '算法']" create_time="2021.10.22 12:18:09.992386" update_time="2021.10.22 12:21:52" />

^^^^^^^^^
<h2 id="r05ya"><span style="font-weight: normal;">1.回文数</span></h2><div><pre>'''给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。<br>示例 1：<br><br>输入：x = 121<br>输出：true<br>示例&nbsp;2：<br><br>输入：x = -121<br>输出：false<br>解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3：<br><br>输入：x = 10<br>输出：false<br>解释：从右向左读, 为 01 。因此它不是一个回文数。<br>示例 4：<br><br>输入：x = -101<br>输出：false<br><br>提示：<br>-231&nbsp;&lt;= x &lt;= 231&nbsp;- 1<br>来源：力扣（LeetCode）<br>链接：https://leetcode-cn.com/problems/palindrome-number<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。'''<br><br>class Solution:<br>    def isPalindrome(self, x: int) -&gt; bool:<br>        original_str=str(x)<br>        # reverse_str=original_str[::-1]<br>        return True if original_str==original_str[::-1] else False<br><br><br>if __name__ == '__main__':<br>    x=-121<br>    print(Solution().isPalindrome(x))</pre></div><div><img src="https://img-blog.csdnimg.cn/bb1218b325f9460ea66cfe36e9ab1b99.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGl0dGxl5Lqu772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" width="50%"><span style="font-weight: normal;"><br></span></div><pre><br></pre><p data-we-empty-p=""><br></p><h2 id="motpf">2.盛最多容器的水</h2><pre>'''给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点&nbsp;(i,&nbsp;ai) 。在坐标内画 n 条垂直线，垂直线 i&nbsp;的两个端点分别为&nbsp;(i,&nbsp;ai) 和 (i, 0) 。找出其中的两条线，使得它们与&nbsp;x&nbsp;轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器。<br><br>示例 1：<br><br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。<br>示例 2：<br><br>输入：height = [1,1]<br>输出：1<br>示例 3：<br><br>输入：height = [4,3,2,1,4]<br>输出：16<br>示例 4：<br><br>输入：height = [1,2,1]<br>输出：2<br>&nbsp;<br>提示：<br><br>n == height.length<br>2 &lt;= n &lt;= 105<br>0 &lt;= height[i] &lt;= 104<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode-cn.com/problems/container-with-most-water<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。'''<br>from typing import List<br><br>#暴力解法<br># class Solution:<br>#     def maxArea(self, height: List[int]) -&gt; int:<br>#         maxValue=0<br>#         for i in range(len(height)):<br>#             for k in range(i+1,len(height)):<br>#                 width=k-i<br>#                 heigh=height[i] if height[i]&lt;=height[k] else height[k]<br>#                 curValue=width*heigh<br>#                 maxValue=curValue if curValue&gt;maxValue else maxValue<br>#         return maxValue<br><br><br><br>#双指针法<br>'''<br>设置两个指针left,right,分别从数组list的最左边和最右边开始<br>所以当前两个指针所指的值分别为:list[left] list[right]<br><br>因为影响容器面积的因素有两个,宽度width和高度height(height=min(list[left],list[right]))<br>所以左指针和右指针分别指向数组的两头,让width的值最大 当前area=width*height<br>指针移动的条件:向里移动所指向的值较小的那个指针<br><br>'''<br><br>class Solution:<br>    def maxArea(self, height: List[int]) -&gt; int:<br>        left=0<br>        right=len(height)-1<br><br>        maxArea_=0<br>        while left!=right:<br>            width=right-left<br>            leftValue=height[left]<br>            rightValue=height[right]<br>            heigh=min(leftValue,rightValue)<br>            curArea=width*heigh<br>            maxArea_=curArea if curArea&gt;maxArea_ else maxArea_<br>            #移动指针<br>            if leftValue&lt;rightValue:<br>                left+=1<br>            else:<br>                right-=1<br>        return maxArea_<br><br><br>if __name__ == '__main__':<br>    height=[1,1]<br>    print(Solution().maxArea(height))<br></pre><p data-we-empty-p=""><img src="https://img-blog.csdnimg.cn/0afbf4a5c6a94eccb9e555447ad1a2f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGl0dGxl5Lqu772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" width="50%"><br></p><pre><br></pre><h2 id="8a25b">3.最长公共前缀</h2><pre>'''编写一个函数来查找字符串数组中的最长公共前缀。<br><br>如果不存在公共前缀，返回空字符串&nbsp;""。<br>示例 1：<br><br>输入：strs = ["flower","flow","flight"]<br>输出："fl"<br>示例 2：<br><br>输入：strs = ["dog","racecar","car"]<br>输出：""<br>解释：输入不存在公共前缀。<br>&nbsp;<br><br>提示：<br><br>1 &lt;= strs.length &lt;= 200<br>0 &lt;= strs[i].length &lt;= 200<br>strs[i] 仅由小写英文字母组成<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode-cn.com/problems/longest-common-prefix<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。'''<br>from typing import List<br>class Solution:<br>    def longestCommonPrefix(self, strs: List[str]) -&gt; str:<br>        strs = sorted(strs, key=lambda a: len(a))<br>        str_ = strs[0]<br>        length = 0<br>        # 从第二个字符串开始,依次比对它们的前n个字符是否相同<br>        for byte_index in range(len(str_)):<br>            flag = 1<br>            for i in range(1, len(strs)):  # 从第二个字符开始<br>                if strs[i][byte_index] != str_[byte_index]:<br>                    flag = 0<br>                    break<br>            if flag:<br>                length += 1<br>            else:<br>                break<br><br>        return str_[:length]<br><br>if __name__ == '__main__':<br>    strs = ["flower","flow","flight"]<br><br>    print(Solution().longestCommonPrefix(strs))</pre><p><br></p><p data-we-empty-p=""><img src="https://img-blog.csdnimg.cn/0f2ce23928e54007b2d79d1c518fa08b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGl0dGxl5Lqu772e,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" width="50%"><br></p><pre><br></pre>
