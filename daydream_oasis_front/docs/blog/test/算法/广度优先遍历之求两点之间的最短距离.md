
<BlogInfo title="广度优先遍历之求两点之间的最短距离" author="白日梦想猿" pv=0 read_times=0 pre_cost_time=80 category="算法" tag_list="['z最短距离', 'bfs']" create_time="2022.05.31 17:43:23.216803" update_time="2022.05.31 17:43:23" />

^^^^^^^^^
<p>&nbsp;</p>

<pre data-widget="codeSnippet">
<code class="hljs language-python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span>
<span class="hljs-string">&#39;&#39;&#39;
   *****************LLL*********************
   * @Project ：leetcode                       
   * @File    ：lll_106求顶点到各个节点的最短路径.py
   * @IDE     ：PyCharm             
   * @Author  ：LLL                         
   * @Date    ：2022/5/31 9:45             
   *****************************************
&#39;&#39;&#39;</span>
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-comment"># 邻接表来表示图</span>
graph = {
    <span class="hljs-number">1</span>: {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>},
    <span class="hljs-number">2</span>: {<span class="hljs-number">1</span>, <span class="hljs-number">4</span>},
    <span class="hljs-number">3</span>: {<span class="hljs-number">1</span>, <span class="hljs-number">4</span>},
    <span class="hljs-number">4</span>: {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>},
    <span class="hljs-number">5</span>: {<span class="hljs-number">4</span>}
}


<span class="hljs-comment"># 广度优先遍历求解最短距离</span>
<span class="hljs-keyword">def</span> <span class="function_ hljs-title">bfs_min_distance</span>(<span class="hljs-params">root, target</span>):
    queue = deque()
    visited_dic = {node: <span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph}  <span class="hljs-comment"># 记录节点是否被访问</span>
    d_dic = {node: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph}  <span class="hljs-comment"># 记录根节点到每一个节点的最短路径</span>
    path_path = {node: <span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph}  <span class="hljs-comment"># 记录每一个节点的直接前驱</span>

    <span class="hljs-comment"># 首先将根节点加入队列中</span>
    queue.append(root)
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue):
        cur_node = queue.popleft()

        neighbor_nodes = graph[cur_node]
        <span class="hljs-keyword">for</span> neighbor_node <span class="hljs-keyword">in</span> neighbor_nodes:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited_dic[neighbor_node]:  <span class="hljs-comment"># 如果相邻的节点没有被访问就加入到队列中</span>
                queue.append(neighbor_node)
                path_path[neighbor_node] = cur_node  <span class="hljs-comment"># 前驱为当前节点</span>
                d_dic[neighbor_node] = d_dic[cur_node] + <span class="hljs-number">1</span>  <span class="hljs-comment"># 到根节点的距离=前驱节点到根节点的距离+1</span>

        visited_dic[cur_node] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 当前节点已被访问</span>

    <span class="hljs-comment"># 根节点到目标节点的路径</span>
    end = target
    path = [end]
    <span class="hljs-keyword">while</span> end:
        end = path_path[end]
        path.append(end)
    path.pop()
    path.reverse()

    <span class="hljs-keyword">return</span> path, d_dic[target]


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#39;__main__&#39;</span>:
    <span class="hljs-built_in">print</span>(bfs_min_distance(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>))
</code></pre>

<p>&nbsp;</p>

<p>其实原理上还是广度优先遍历(或者说是层序遍历可能会更形象一些)，只不过除了需要一个队列来记录访问的顺序外，这里额外定义了3个字典保存一些附带的信息：</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited_dic = {node: False for node in graph} &nbsp;# 记录节点是否被访问</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d_dic = {node: 0 for node in graph} &nbsp;# 记录根节点到每一个节点的最短路径<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path_path = {node: None for node in graph} &nbsp;# 记录每一个节点的直接前驱</p>

<p><img alt="" data-widget="image" isbindedload="true" src="https://img-blog.csdnimg.cn/c08fd7e1cbfe46eabe1e255f9e2a50d3.png" style="height:454px; width:890px" /></p>

<p>&nbsp;访问到当前节点时，首先获取当前节点的邻接节点，然后遍历这些邻接节点，只要是没有访问的邻接节点就将其加入队列中，然后更新这个邻接节点的前驱（就是当前节点），然后更新根节点到这个邻接节点的距离（到根节点的距离=前驱节点到根节点的距离+1），最后修改当前节点为已访问的。（<strong>这个可能有点不好理解，所以要想搞懂最好可以拿一张草稿画一下这个过程</strong>）</p>

<p>访问每一个节点的操作都是如上重复的操作，直到访问到所有节点为止。</p>

<p><img src="../media/image/2022/05/31/image-20220531174248-2.png" style="height:916px; width:900px" /></p>

<p>&nbsp;</p>

