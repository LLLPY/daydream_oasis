
<BlogInfo title="选择排序" author="白日梦想猿" pv=0 read_times=0 pre_cost_time=36 category="排序算法" tag_list="['选择排序', '排序算法']" create_time="2022.04.28 16:48:07.807678" update_time="2022.04.28 18:27:20" />

^^^^^^^^^
<h1>&nbsp;思路</h1>

<blockquote>
<pre>
# 思路：每次选择出列表中的最大(小)值，然后将其从列表中移除，并将移除的值依次排列</pre>
</blockquote>

<h1>基础版</h1>

<pre>
<code>@clocked
def select_sort(li):
    li_len = len(li)
    new_li = []
    for i in range(li_len):
        # 选出最小元素
        min_val = min(li)
        # 删除这个元素
        li.remove(min_val)
        # 将这个元素添加到一个新的列表中
        new_li.append(min_val)

    return new_li</code></pre>

<h1>&nbsp;优化</h1>

<p>可以看到，上面的排序中，需要我们额外的申请一个数组，这样非常的消耗资源！比如一个1M的列表，经过排序后就会变成2M，如果是1G，经过排序后就会变成2G，所以是非常耗资源的，那么有没有可以优化的地方呢？</p>

<blockquote>
<pre>
&#39;&#39;&#39;
答案是肯定的！就是原地排序。
原地排序，排序过程中，将列表分为两部分，左边设为有序区，右边设为无序区
每次选择无序区中的最小值和无序区中的第一个进行交换，交换完成之后，将其
合并到有序区，直到无序区只有一个元素，排序完成！
&#39;&#39;&#39;</pre>
</blockquote>

<div class="csdn-data-video">&nbsp;
<p>选择排序</p>
</div>

<pre>
<code>@clocked
def select_sort2(li):
    li_len = len(li)
    for i in range(li_len - 1):
        min_loc = i  # 记录最小值的位置
        for j in range(i + 1, li_len):  # w无序区：[i,li_len-1]
            # 找出最小值
            if li[j] &lt; li[min_loc]:
                min_loc = j
        li[i], li[min_loc] = li[min_loc], li[i]</code>
</pre>

<h1>测试</h1>

<p><img src="../media/image/2022/04/28/image-20220428164734-1.png" style="height:635px; width:900px" /></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

