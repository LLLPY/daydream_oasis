
<BlogInfo title="穷举法之平均损失值的计算" author="白日梦想猿" pv=0 read_times=0 pre_cost_time=179 category="人工智能" tag_list="['人工智能', 'MSE', '穷举法']" create_time="2021.07.14 18:46:47.589581" update_time="2021.07.14 18:51:19" />

^^^^^^^^^
<p></p><h2><span style="font-size: 16px; letter-spacing: 2px; word-spacing: 1px;">import numpy as np</span></h2><p><span style="font-weight: normal;">​import matplotlib.pyplot as plt</span></p><p>from mpl_toolkits.mplot3d import Axes3D</p><p></p><p></p><h1><a></a>例给出一组训练集的数据如下:</h1><p></p><p></p><p>x_list = [1.0, 2.0, 3.0]<br>y_list = [2.0, 4.0, 6.0]</p><p></p><p></p><h1><a></a>问:如果x取4的时候,y的值为多少?</h1><p></p><p></p><h1><a></a>很明显,x和y之间存在着种线性关系 即y=w*x+b</h1><p></p><p></p><h1><a></a>如果确定了w和b的值 那么问题就好解决了</h1><p></p><p></p><h1><a></a>解决思路</h1><p></p><p></p><h1><a></a>1.模型简化 去掉b,直接令y=w*x</h1><p></p><p></p><h1><a></a>2.确定w的值</h1><p></p><p></p><p>‘’’<br>利用穷举法来确定w的值<br>a.首先大致估计w的取值范围,然后在这个范围内,去每一个w的值,算出对应的损失(loss)<br>b.计算每一个样本的损失的方法(样本损失):<br>公式: loss=(Y-y)**2 其中:Y:为计算值 y:为实际值<br>例:当w=1 x=1时 计算得出的Y值为:1 真实的y值为:2<br>那么损失loss=(1-2)**2=1 此损失称为样本损失<br>c.计算平均损失(平均损失mse(mean square error)):<br>公式:mean=avg(loss1+loss2+…) 即取所有样本损失的平均值<br>d.将平均损失mean的值来作为w的权重,mean值越小,说明损失越小,估计值也就越接近真实值,w的权重也就越高<br>e.权重最高的w即为我们要确定的w<br>‘’’</p><p></p><p></p><h1><a></a>以此例 绘制不同w值其对应的平均损失(mse)</h1><p></p><p></p><p>w_list = [] # 存放穷举的w值的列表<br>mse_list = [] # 存放w对应mse的列表</p><p></p><p></p><h1><a></a>定义计算样本损失的方法</h1><p></p><p></p><p>def loss(y, y_pred):<br>return (y - y_pred) ** 2</p><p></p><p></p><h1><a></a>定义计算求预测值的方法</h1><p></p><p></p><p>def forward(w, x):<br>return w * x</p><p></p><p></p><h1><a></a>假设w的大致取值范围为[0,4]</h1><p></p><p></p><p>for w in np.arange(0.0, 4.1, 0.1):<br>w_list.append(w)</p><pre><code>sum_mse = 0  # 用于记录w取不同值时下的mse的总和 总损失for x, y in zip(x_list, y_list):    y_pred = forward(w, x)    loss_ = loss(y, y_pred)    sum_mse += loss_mse = sum_mse / len(x_list)  # 平均损失=总损失/样本数mse_list.append(mse)</code></pre><p></p><p></p><h1><a></a>绘图</h1><p></p><p></p><p>plt.plot(w_list, mse_list)<br>plt.title(‘MSE-w’)<br>plt.xlabel(‘w’)<br>plt.ylabel(‘Mean Square Error’)<br>plt.savefig(‘w-MSE曲线图’)<br>plt.show()</p><p></p><p></p><p><img src="https://img-blog.csdnimg.cn/20210714184323686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21heF9MTEw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p></p><p></p><h1><a></a>以同样的方法来确定b的值 同时画出平均损失关于w和b的图像</h1><p></p><p></p><h1><a></a>同上一次的确定方法相比 其实只用多加一层关于b的取值循环即可</h1><p></p><p></p><h1><a></a>假设w的大致取值范围为[0,4] b的大致取值范围在[-2,2]</h1><p></p><p></p><p>b_list = []<br>w_list = []<br>mse_list=[]<br>for w in np.arange(0.0, 4.1, 0.1):</p><pre><code>for b in np.arange(-2.0, 2.1, 0.1):    w_list.append(w)    b_list.append(b)    sum_mse = 0  # 用于记录w取不同值时下的mse的总和 总损失    for x, y in zip(x_list, y_list):        y_pred = forward(w, x)        loss_ = loss(y, y_pred)        sum_mse += loss_    mse = sum_mse / len(x_list)  # 平均损失=总损失/样本数    mse_list.append(mse)</code></pre><p></p><p></p><p>#绘图 此时有三个维度的数据,所以应该绘制三维的图形<br>figure=plt.figure(‘3D Surface’,facecolor=‘lightgray’)</p><p></p><p></p><p>#设置为3D图片类型<br>ax3d=Axes3D(figure)<br>ax3d.set_title(‘MSE-b,w’)<br>ax3d.set_xlabel(‘w’)<br>ax3d.set_ylabel(‘b’)<br>ax3d.set_zlabel(‘MSE’)</p><p></p><p></p><p>ax3d.plot_trisurf(b_list,w_list,mse_list)<br>plt.savefig(‘w,b对应的MSE取值’)<br>plt.show()<br><img src="https://img-blog.csdnimg.cn/20210714184335892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21heF9MTEw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><a href="https://blog.csdn.net/max_LLL/article/details/118734583" target="_blank">csdn链接</a><br></p><p data-we-empty-p=""><br></p><p data-we-empty-p="">源码:</p><pre>import numpy as np<br>import matplotlib.pyplot as plt<br>from mpl_toolkits.mplot3d import Axes3D<br><br># 例给出一组训练集的数据如下:<br>x_list = [1.0, 2.0, 3.0]<br>y_list = [2.0, 4.0, 6.0]<br><br># 问:如果x取4的时候,y的值为多少?<br># 很明显,x和y之间存在着种线性关系 即y=w*x+b<br># 如果确定了w和b的值 那么问题就好解决了<br><br># 解决思路<br># 1.模型简化 去掉b,直接令y=w*x<br># 2.确定w的值<br>'''<br>利用穷举法来确定w的值<br>    a.首先大致估计w的取值范围,然后在这个范围内,去每一个w的值,算出对应的损失(loss)<br>    b.计算每一个样本的损失的方法(样本损失):<br>        公式: loss=(Y-y)**2 其中:Y:为计算值 y:为实际值<br>        例:当w=1 x=1时 计算得出的Y值为:1 真实的y值为:2<br>          那么损失loss=(1-2)**2=1 此损失称为样本损失<br>    c.计算平均损失(平均损失mse(mean square error)):<br>        公式:mean=avg(loss1+loss2+...) 即取所有样本损失的平均值 <br>    d.将平均损失mean的值来作为w的权重,mean值越小,说明损失越小,估计值也就越接近真实值,w的权重也就越高<br>    e.权重最高的w即为我们要确定的w<br>'''<br><br># 以此例 绘制不同w值其对应的平均损失(mse)<br><br>w_list = []  # 存放穷举的w值的列表<br>mse_list = []  # 存放w对应mse的列表<br><br><br># 定义计算样本损失的方法<br>def loss(y, y_pred):<br>    return (y - y_pred) ** 2<br><br><br># 定义计算求预测值的方法<br>def forward(w, x):<br>    return w * x<br><br><br># 假设w的大致取值范围为[0,4]<br>for w in np.arange(0.0, 4.1, 0.1):<br>    w_list.append(w)<br><br>    sum_mse = 0  # 用于记录w取不同值时下的mse的总和 总损失<br>    for x, y in zip(x_list, y_list):<br>        y_pred = forward(w, x)<br>        loss_ = loss(y, y_pred)<br>        sum_mse += loss_<br><br>    mse = sum_mse / len(x_list)  # 平均损失=总损失/样本数<br>    mse_list.append(mse)<br><br># 绘图<br>plt.plot(w_list, mse_list)<br>plt.title('MSE-w')<br>plt.xlabel('w')<br>plt.ylabel('Mean Square Error')<br>plt.savefig('w-MSE曲线图')<br>plt.show()<br><br># 以同样的方法来确定b的值 同时画出平均损失关于w和b的图像<br><br># 同上一次的确定方法相比 其实只用多加一层关于b的取值循环即可<br># 假设w的大致取值范围为[0,4] b的大致取值范围在[-2,2]<br>b_list = []<br>w_list = []<br>mse_list=[]<br>for w in np.arange(0.0, 4.1, 0.1):<br><br>    for b in np.arange(-2.0, 2.1, 0.1):<br><br>        w_list.append(w)<br>        b_list.append(b)<br><br>        sum_mse = 0  # 用于记录w取不同值时下的mse的总和 总损失<br>        for x, y in zip(x_list, y_list):<br>            y_pred = forward(w, x)<br>            loss_ = loss(y, y_pred)<br>            sum_mse += loss_<br><br>        mse = sum_mse / len(x_list)  # 平均损失=总损失/样本数<br>        mse_list.append(mse)<br><br>#绘图 此时有三个维度的数据,所以应该绘制三维的图形<br>figure=plt.figure('3D Surface',facecolor='lightgray')<br><br>#设置为3D图片类型<br>ax3d=Axes3D(figure)<br>ax3d.set_title('MSE-b,w')<br>ax3d.set_xlabel('w')<br>ax3d.set_ylabel('b')<br>ax3d.set_zlabel('MSE')<br><br>ax3d.plot_trisurf(b_list,w_list,mse_list)<br>plt.savefig('w,b对应的MSE取值')<br>plt.show()</pre><p><br></p><p><br></p><p>​</p><p></p>
