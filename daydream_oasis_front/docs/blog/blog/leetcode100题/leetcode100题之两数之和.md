
<BlogInfo title="leetcode100题之两数之和" author="白日梦想猿" pv=0 read_times=0 pre_cost_time=43 category="leetcode100题" tag_list="['hash表']" create_time="2021.09.07 13:38:24.647749" update_time="2021.09.07 13:38:24" />

^^^^^^^^^
<pre><br></pre><h3><b id="i38ix"><font color="#46acc8">"基础不牢,地动山摇",从今天开始,打算在leetcode上进行刷题了~同时将刷题记录在这里,希望对看到的小伙伴也有所帮助~</font></b></h3><pre><br></pre><pre>'''<br><br>给定一个整数数组 nums&nbsp;和一个整数目标值 target，请你在该数组中找出 和为目标值 target&nbsp; 的那&nbsp;两个&nbsp;整数，并返回它们的数组下标。<br><br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br><br>你可以按任意顺序返回答案。<br><br>来源：力扣（LeetCode）<br>链接：https://leetcode-cn.com/problems/two-sum<br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>'''<br><br>nums = [2, 7, 11, 15]<br>target = 9  # 输出：[0,1]<br><br><br></pre><pre># 方法一:二重循环(时间复杂度(O(n²)))<br>def solution1():<br>    for index1 in range(len(nums)):<br>        for index2 in range(len(nums)):<br>            if nums[index1] + nums[index2] and index1 != index2:<br>                return [index1, index2]<br><br><br># 方法二:哈希表(时间复杂度:O(n))<br>'''<br>用空间换区时间,循环遍历nums列表,依次将当前的数记录在hash表中,用当前数的值作key,当前数的索引作value;<br>因为如果当前数(num1)加另外一个数(num2)等于target,那么另外一个数始终等于target-num1,所以在对num2<br>进行查找的时候,直接从hash表中进行查找,这样时间复杂度就降了n维<br><br>'''<br>def solution2():<br>    hashtable = dict()<br>    for index, value in enumerate(nums):<br>        diff = target - value<br>        if diff in hashtable:<br>            return [index, hashtable[diff]]<br>        # 用哈希表记录已访问过的数据<br>        hashtable[value] = index<br><br><br>if __name__ == '__main__':<br>    print(solution1())<br>    print(solution2())<br></pre>
