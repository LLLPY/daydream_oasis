
<BlogInfo title="最长子字符串" author="白日梦想猿" pv=0 read_times=0 pre_cost_time=67 category="leetcode100题" tag_list="['leetcode', '算法']" create_time="2021.09.09 17:07:37.495315" update_time="2021.09.09 17:08:12" />

^^^^^^^^^
<pre>'''<br>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例&nbsp;1:<br><br>输入: s = "abcabcbb"<br>输出: 3<br>解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。<br>示例 2:<br><br>输入: s = "bbbbb"<br>输出: 1<br>解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。<br>示例 3:<br><br>输入: s = "pwwkew"<br>输出: 3<br>解释: 因为无重复字符的最长子串是&nbsp;"wke"，所以其长度为 3。<br>&nbsp;    请注意，你的答案必须是 子串 的长度，"pwke"&nbsp;是一个子序列，不是子串。<br>示例 4:<br><br>输入: s = ""<br>输出: 0<br>'''<br><br><br>#我的思路:<br># 1.遍历当前字符,将字符依次记录到一个字典中 key:字符 value:字符的下标<br><br># 2.在记录过程中,如果字典中已存在即将记录的新字符,记录下此时字典的长度,如果长度大于maxLen的值,<br># 就将其更新为maxLen的值,查找在字典中相同字符的value1值,删除字典中value值小于value1<br># 的元素,将当前元素加入字典<br><br># 3.继续循环遍历直至遍历结束<br><br><br># 解法一<br>def lengthOfLongestSubstring(s):<br>    maxLen = 0<br>    dicTool = dict()<br>    for index in range(len(s)):<br>        if s[index] not in dicTool:<br>            dicTool[s[index]] = index<br>            maxLen = dicTool.__len__() if dicTool.__len__() &gt; maxLen else maxLen<br>        else:<br>            keyList = []<br>            for i in dicTool:<br>                if dicTool[i] &lt;= dicTool[s[index]]:<br>                    keyList.append(i)<br><br>            for key in keyList:<br>                del dicTool[key]<br><br>            dicTool[s[index]] = index<br>    return maxLen<br><br><br># 未解决!<br>def solution(s):<br>    maxLen = 0<br>    if len(s) &lt;= 1:<br>        return len(s)<br>    dicTool = dict()<br>    for index in range(len(s)):<br>        print(dicTool)<br>        if s[index] in dicTool:<br>            old_index = dicTool[s[index]]  # 前一次出现时的索引值<br>            nowLen = index - old_index  # 目前子字符串的长度=当前索引值-同一字符前一次出现的索引值<br>            maxLen = nowLen if nowLen &gt; maxLen else maxLen  # 如果当前之字符串的长度大于maxLen就更新为maxLen的值<br>            valueList = dicTool.values()<br><br>            res = max(valueList) - min(valueList) + 1<br>            maxLen = res if res &gt; maxLen else maxLen<br>            dicTool = {}<br><br>        dicTool[s[index]] = index<br>    valueList = dicTool.values()<br><br>    res = max(valueList) - min(valueList) + 1<br>    maxLen = res if res &gt; maxLen else maxLen<br>    return maxLen<br><br><br>if __name__ == '__main__':<br>    s = "dvdf"<br>    # lengthOfLongestSubstring(s)<br>    maxLen = solution(s)<br>    print(maxLen)<br></pre>
