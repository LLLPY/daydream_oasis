
<BlogInfo title="基于协同过滤的博客推荐系统" author="白日梦想猿" pv=0 read_times=0 pre_cost_time=608 category="毕业论文" tag_list="['博客', '协同过滤']" create_time="2023.06.12 13:28:40.725691" update_time="2023.06.12 13:29:04.678365" />

^^^^^^^^^
<h1 id="基于协同过滤的博客推荐系统"><strong>基于协同过滤的博客推荐系统</strong></h1>
<h1 id="摘要"><strong>摘要</strong></h1>
<p>随着互联网的快速发展，越来越多的人加入了博客创作和阅读的行列，使得博客平台上的内容呈现出爆炸式增长的趋势。然而，这也带来了一个新的挑战，即如何帮助用户在众多博客文章中找到他们感兴趣的内容。在这样的背景下，本文提出了一种基于协同过滤的博客推荐系统，以解决上述问题。协同过滤是一种常用的推荐算法，它利用用户行为数据和博客内容信息来进行个性化推荐。该系统首先收集用户的历史阅读记录和行为数据，如浏览记录、点赞和评论等，以了解用户的兴趣和偏好。然后，通过分析博客文章的内容特征，如主题、关键词等，建立起博客之间的相似性关系。基于这些信息，系统可以为每个用户生成个性化的推荐列表。我们使用Python语言进行开发，前端采用交互式的框架Vue，后端采用功能完备的Django框架进行开发，并最终使用Nginx和uwsgi进行部署运行；在系统的实现过程中，为了提高推荐的准确性和多样性，我们还采用了一些改进策略。首先，引入了时间衰减因子，让新发布的文章也有充足的展示空间，其次，对用户的历史行为进行加权，以更好地反映用户的当前兴趣。在完成本项目后，最终实验结果表明，该基于协同过滤的博客推荐系统在提供个性化推荐方面具有良好的性能。与传统的热门文章推荐方法相比，该系统能够更准确地捕捉用户的兴趣和偏好，并为其推荐具有高度相关性和多样性的博客文章。</p>
<p>关键词：协同过滤算法； 推荐系统； 博客； 个性化推荐； Django； nginx；uwsgi</p>
<h1 id="ABSTRACT">ABSTRACT</h1>
<p>With the rapid development of the Internet, more and more people join the ranks of blog creation and reading, which makes the content on the blog platform show an explosive growth trend. However, this presents a new challenge in helping users find what they are interested in among the many blog posts. In this context, this paper proposes a blog recommendation system based on collaborative filtering to solve the above problems. Collaborative filtering is a common recommendation algorithm which makes use of user behavior data and blog content information to make personalized recommendation. The system first collects historical reading records and behavioral data, such as browsing history, likes and comments, to understand users&#39; interests and preferences. Then, by analyzing the content features of blog articles, such as themes, keywords, etc., the similarity relationship between blogs is established. Based on this information, the system can generate a personalized recommendation list for each user. We use Python language for development. The front-end uses the interactive framework Vue, the back-end uses the fully-functional Django framework for development, and finally uses Nginx and uwsgi for deployment and operation. During the implementation of the system, in order to improve the accuracy and diversity of recommendations, we also adopted some improvement strategies. First, a time decay factor was introduced to allow ample room for new posts, and second, historical user behavior was weighted to better reflect users&#39; current interests. After the completion of this project, the final experimental results show that the blog recommendation system based on collaborative filtering has good performance in providing personalized recommendation. Compared with traditional popular article recommendation methods, the system can more accurately capture users&#39; interests and preferences and recommend highly relevant and diverse blog articles for them.</p>
<p><strong>Keywords</strong>**：**collaborative filtering algorithm; Recommendation system; Blog; Personalized recommendation; Django; nginx; uwsgi</p>
<p>目    录</p>
<p><a href="#_Toc3509">基于协同过滤的博客推荐系统	</a></p>
<p><a href="#_Toc8960">摘  要	</a></p>
<p><a href="#_Toc27481">ABSTRACT	</a></p>
<p><a href="#_Toc15700">一、 引言	</a></p>
<p><a href="#_Toc15162">1.1 研究背景和意义	</a></p>
<p><a href="#_Toc26794">二、相关技术和理论	</a></p>
<p><a href="#_Toc16738">2.1 协同过滤推荐算法	</a></p>
<p><a href="#_Toc20692">2.2 Python语言介绍	</a></p>
<p><a href="#_Toc24480">2.3 Vue框架介绍	</a></p>
<p><a href="#_Toc7685">2.4 Django框架介绍	</a></p>
<p><a href="#_Toc31726">2.5 nginx介绍	</a></p>
<p><a href="#_Toc19094">2.6 uwsgi介绍	</a></p>
<p><a href="#_Toc19041">三、博客推荐系统设计和实现	</a></p>
<p><a href="#_Toc22762">3.1 需求分析	</a></p>
<p><a href="#_Toc20484">3.1.1功能需求	</a></p>
<p><a href="#_Toc23873">3.1.2非功能需求	</a></p>
<p><a href="#_Toc3546">3.1.3技术需求	</a></p>
<p><a href="#_Toc9043">3.2概要设计	</a></p>
<p><a href="#_Toc7305">3.2.1系统整体框架	</a></p>
<p><a href="#_Toc13748">3.2.2功能模块划分	</a></p>
<p><a href="#_Toc32068">3.2.3模型设计	</a></p>
<p><a href="#_Toc24382">3.3 使用Django框架实现博客系统	</a></p>
<p><a href="#_Toc8511">3.3.1用户相关	</a></p>
<p><a href="#_Toc14693">3.3.2博客相关	</a></p>
<p><a href="#_Toc21668">3.3.3交互相关	</a></p>
<p><a href="#_Toc7488">3.3.4筛选相关	</a></p>
<p><a href="#_Toc25618">3.3.5统计相关	</a></p>
<p><a href="#_Toc7831">3.3.6文件相关	</a></p>
<p><a href="#_Toc12107">3.3.7管理相关	</a></p>
<p><a href="#_Toc13525">3.3.8总结	</a></p>
<p><a href="#_Toc21493">3.4 收集用户数据	</a></p>
<p><a href="#_Toc9034">3.5 使用Python实现协同过滤算法	</a></p>
<p><a href="#_Toc15196">3.5.1计算用户相似度	</a></p>
<p><a href="#_Toc31845">3.5.2预测用户对物品的评分	</a></p>
<p><a href="#_Toc2874">3.5.3为用户推荐	</a></p>
<p><a href="#_Toc24537">3.6应用协同过滤算法至博客系统	</a></p>
<p><a href="#_Toc14805">3.7 使用nginx和uwsgi部署	</a></p>
<p><a href="#_Toc21191">3.7.1编写uwsgi配置文件	</a></p>
<p><a href="#_Toc18416">3.7.2编写nginx的配置文件	</a></p>
<p><a href="#_Toc19045">3.7.3模型迁移和收集静态文件	</a></p>
<p><a href="#_Toc30564">3.7.4启动服务	</a></p>
<p><a href="#_Toc1215">四、总结与展望	</a></p>
<p><a href="#_Toc19290">4.1 总结	</a></p>
<p><a href="#_Toc26744">4.2 展望	</a></p>
<p><a href="#_Toc18301">参考文献	</a></p>
<p><a href="#_Toc11204">致谢	</a></p>
<h1 id="一-引言">一、引言</h1>
<h2 id="1-1-研究背景和意义">1.1 研究背景和意义</h2>
<p>随着信息技术的不断进步，各式各样的互联网应用不断涌现，网站模式也从以文章为中心变成以用户为中心，用户逐渐喜欢了在网上创作和分享等，使得信息量呈指数级的爆炸增长，面对如此庞大的信息量，用户很难找到自己感兴趣的东西。</p>
<p>在这样的背景下，通过关键字搜索查找自己感兴趣内容的搜素引擎应运而生，在大多数情况下，用户往往不明白自己的需求是什么，或者在搜索时使用的关键字“词不达意”，从而无法得到自己想要的内容，同时，搜索引擎用户量巨大，往往考虑的不是某一个人，而是某一群人，但在实际生活中，用户A和用户B他们使用相同的关键词去搜索内容，他们得到的内容很大程度上是一样的，但是用户A和用户B他们原本想要表达的意思可能大相径庭，但是搜索引擎为了考虑大多数人群，从而导致无法满足个性化的需求^[1]^。</p>
<p>在这样情形下推荐系统应运而生。自20世纪90年代以来，以国外亚马逊、Ebay，国内淘宝、京东为代表的电子商务蓬勃 兴起，电子支付日益成熟，信息安全也不断完善，使推荐系统有个更大的发展空间 。在巨大市场需求的带动下，推荐系统在工业界和学术界获得了广泛使用，更多的国内外学者开始研究推荐系统，ACM、CCIR、SIGIR、RecSys等众多国内外会议期刊收录的推荐系统相关 的 文章越来越多。我国也比较重视推荐系统的研究和应用，国家自然科学基金支持很多推荐系统相关课题，中国推荐系统大会每年举办一次，汇集了国内一些走在前沿的推荐系统专家^[2]^。</p>
<p>博客是一种常见的网络媒体，它为用户提供了一个自由、开放、多元的信息交流平台。随着博客的数量不断增加，用户需要花费大量时间才能找到自己感兴趣的内容。因此，设计一个基于协同过滤算法的博客推荐系统，对于提高用户的使用体验和博客平台的活跃度具有重要意义。</p>
<h1 id="二-相关技术和理论">二、相关技术和理论</h1>
<h2 id="2-1-协同过滤推荐算法">2.1 协同过滤推荐算法</h2>
<p>协同过滤是一种经典的推荐算法，它基于用户的历史行为和兴趣，寻找相似的用户或项目，并通过这些相似性来预测用户可能感兴趣的内容。本文中，我们将使用基于用户的协同过滤算法，其中我们将计算用户之间的相似度，并推荐给用户类似于他们历史上阅读过的博客。</p>
<p>协同过滤算法的核心思想是根据用户的行为历史（例如，点击、购买、评论等）来推荐他们可能感兴趣的物品。在博客推荐系统中，我们可以根据用户对博客的浏览历史和收藏历史等信息，计算用户之间的相似度，并将这些相似用户的浏览历史作为推荐给目标用户的博客^[3]^。</p>
<h2 id="2-2-Python语言介绍">2.2 Python语言介绍</h2>
<p>Python是一种高级、解释性、面向对象的编程语言，被广泛应用于科学计算、数据分析、人工智能、Web开发等领域。Python具有简单易学、代码可读性高、语法简洁、跨平台等特点，是一种非常流行的编程语言。</p>
<p>Python的语法简洁清晰，使用缩进来表示代码块，避免了繁琐的语法规则。同时，Python支持面向对象编程，具有封装、继承和多态等特性，可以方便地组织代码，使得程序具有更好的可维护性和可扩展性。</p>
<p>Python有丰富的Web开发框架和库，如Django、Flask等，可帮助开发者快速搭建Web应用程序，同时提供高级功能和工具，如ORM、数据库访问、模板引擎等，开发Web应用更加简单快捷。Python的语法简洁、库和框架丰富，可提高开发效率，是Web开发的优选语言之一。</p>
<h2 id="2-3-Vue框架介绍">2.3 Vue框架介绍</h2>
<p>Vue.js是一款流行的前端JavaScript框架，可以用于构建交互式的Web界面。Vue.js的核心思想是通过组件化来构建应用，每个组件都具有独立的状态和行为，可以相互嵌套和组合，从而构建出复杂的应用程序。Vue.js还提供了响应式数据绑定、虚拟DOM、模板语法、生命周期钩子、指令等功能，使得开发人员能够更加高效地构建Web应用。</p>
<p>Vue.js的响应式数据绑定能力是其最大的特点之一。当应用状态改变时，Vue.js会自动更新页面上对应的DOM元素，使得应用更加动态、高效。同时，Vue.js还支持虚拟DOM技术，可以减少DOM操作的次数，提升应用性能。Vue.js还提供了一套简单易用的模板语法，可以方便地将组件的数据和视图进行绑定，使得数据绑定更加方便。</p>
<h2 id="2-4-Django框架介绍">2.4 Django框架介绍</h2>
<p>Django是一个用于构建Web应用程序的高级Python Web框架。它提供了一种快速而高效的方式来构建Web应用程序，并且可以轻松地与Python的各种科学计算和机器学习工具进行集成。在本文中，我们将使用Django框架来实现我们的博客推荐系统。</p>
<p>Django框架可以大大简化Web应用程序的开发过程，它提供了许多强大的功能，如用户认证、ORM、模板引擎等，使得开发者可以专注于业务逻辑而不必过多考虑底层细节。此外，Django还支持各种数据库和缓存后端，可以灵活地适应各种场景。</p>
<h2 id="2-5nginx介绍">2.5nginx介绍</h2>
<p>Nginx是一种高性能的HTTP和反向代理服务器，也可用于邮件代理服务器和通用的TCP/UDP代理服务器。Nginx在高并发量的情况下表现出色，可同时处理数百万请求，并提供高可用性和可伸缩性。</p>
<p>Nginx具有简单的配置和灵活的扩展性，能够轻松处理虚拟主机、负载均衡、SSL协议和缓存等功能。Nginx还能够运行在多种操作系统上，并且使用非常简单，可以在短时间内安装、配置和使用。</p>
<p>Nginx的反向代理功能可以将客户端的请求转发到后端的Web服务器上，实现负载均衡和提高性能。同时，Nginx还支持FastCGI、uWSGI、SCGI等协议，可以将Web服务器与应用程序分离，使得Web服务器更加灵活和可扩展^[4]^。</p>
<h2 id="2-6-uwsgi介绍">2.6 uwsgi介绍</h2>
<p>uWSGI是一种Web服务器和应用程序容器，它支持多种协议和语言，如WSGI、HTTP、FastCGI、uWSGI等，可以与多种Web服务器、应用服务器、应用程序框架和语言库配合使用。</p>
<p>uWSGI可以提高Web应用程序的性能和可靠性，它的运行模式可以根据需要选择多进程、多线程、协程等模式，支持内存共享和多进程管理，还能够实现负载均衡、快速部署和容器化等功能。</p>
<h1 id="三-博客推荐系统设计和实现">三、博客推荐系统设计和实现</h1>
<h2 id="3-1-需求分析">3.1 需求分析</h2>
<h3 id="3-1-1功能需求">3.1.1功能需求</h3>
<p>用户注册/登录功能：用户可以注册一个账号，进行登录。</p>
<p>个人信息管理功能：用户可以修改个人信息，如昵称、头像、个人简介等。</p>
<p>博客发布功能：用户可以发布博客，包括标题、正文、标签等信息，并选择是否公开。</p>
<p>博客编辑功能：用户可以对自己发布的博客进行编辑，包括标题、正文、标签等信息。</p>
<p>博客删除功能：用户可以删除自己发布的博客。</p>
<p>博客点赞功能：用户可以对其他用户发布的博客进行点赞。</p>
<p>博客评论功能：用户可以对其他用户发布的博客进行评论。</p>
<p>博客收藏功能：用户可以收藏其他用户发布的博客。</p>
<p>博客推荐功能：系统根据用户的历史行为，为用户推荐可能感兴趣的博客。</p>
<h3 id="3-1-2非功能需求">3.1.2非功能需求</h3>
<p>安全性：系统需要对用户信息进行保护，如密码加密存储、防止SQL注入等。</p>
<p>可靠性：系统需要具备较高的稳定性和可靠性，确保用户数据不会因系统故障而丢失。</p>
<p>可用性：系统需要易于使用，用户体验友好。</p>
<p>性能：系统需要具备较高的性能，如快速响应用户请求、较短的加载时间等。</p>
<p>扩展性：系统需要具备良好的扩展性，能够满足用户需求的增长。</p>
<h3 id="3-1-3技术需求">3.1.3技术需求</h3>
<p>语言：系统采用Python语言开发。</p>
<p>框架：系统前端采用Vue框架，后端采用Django框架，使用MVC的开发模式。</p>
<p>数据库：系统采用MySQL数据库存储用户数据和博客数据，采用Redis做数据缓存。</p>
<p>推荐算法：系统采用协同过滤算法作为博客推荐算法。</p>
<h2 id="3-2概要设计">3.2概要设计</h2>
<h3 id="3-2-1系统整体框架">3.2.1系统整体框架</h3>
<p>用户在请求页面后，请求首先会被代理服务nginx捕获，在事先定义好nginx和uwsgi之间的网关协议后，如果是请求的是当前的博客系统，nginx会将请求转发给uwsgi，uwsgi再去请求的具体的应用，也就是当前的博客系统，在博客系统中，首先会将这个请求封装成一个请求对象，进入系统后首先会来到中间件层，如果在中间件中没有对请求执行响应操作，之后就会流入到业务层（model，view和templates），进入业务层，首先会根据请求地址由view层负责进行路由分发，将请求分发到具体的视图函数中进行处理，再由视图函数和数据层进行交互，在处理完业务逻辑后，通过templates层对返回结果渲染，打包成一个响应对象，最后再进行返回。需要注意的是，在model，templates和view处理整个业务流程时，中间件是一直贯穿其中的。系统应用层整体采用MTV框架模式，即模型Model，视图View和模版Templates。同时使用redis数据库用作缓存，前后端数据交互使用form表单以及异步传输数据的ajax进行^[5]^。系统的整体架构图如下所示:</p>
<p><img src="../../../media/image/2023/06/12/image.4da8ae6a08df11eeb56f1f971a1babd2.png" alt="image.4da8ae6a08df11eeb56f1f971a1babd2.png" /></p>
<p>图1.系统架构图</p>
<h3 id="3-2-2功能模块划分">3.2.2功能模块划分</h3>
<p>根据功能的不同，可以系统整体分为如下7大模块，分别是用户模块，博客模块，交互模块，筛选模块，统计模块，管理模块，以及推荐模块。</p>
<p>用户模块：用户模块包含的主要功能是注册，登录和修改密码，其核心功能就是身份验证，将需要登录和不需要登录才能使用的功能区分，同时，用户模块在推荐模块中也起着一定的作用，对于登录后的用户能够唯一标识，精确记录操作历史，从而实现更好的推荐效果。</p>
<p>博客模块：博客模块中，主要涉及的功能就是对博客的增删改查，除了显示博客的功能，其他功能都依赖用户模块，例如：写博客，更新博客和删除博客都需要登录后才能进行；</p>
<p>交互模块：交互模块包含了点赞，收藏，留言和评论功能，是用户和博主进行交流的功能模块。</p>
<p>筛选模块：为了方便用户查找想要的内容，给用户提供检索功能，分为关键词检索，分类检索和标签检索。</p>
<p>统计模块：统计模块包含的主要功能有排行榜统计和访问量统计，在排行榜中统计了天/周/月热度最高的博客，同事对于整站的访问量后台以及用户的行为也会进行统计分析。</p>
<p>管理模块：在管理模块中，主要包含的功能是用户管理，博客管理和权限管理，是面向管理员的，操作能够对整站产生影响。在用户管理模块中，可以进行新增，删除，修改用户等操作，同时能够对用户的权限进行具体的划分，比如：对某一个模型的查询，删除，更新等功能都能明确划分；在管理模块中，能够对整站的博客进行管理；在权限管理中，能够划分权限组，为用户授权或添加到特定的权限组等功能。</p>
<p>推荐模块：根据统计模块中统计到的用户行为数据，应用协同过滤算法进行计算得出推荐列表。功能模块划分图如下：</p>
<p><img src="../../../media/image/2023/06/12/image.67d4a3e808df11eeb56f1f971a1babd2.png" alt="image.67d4a3e808df11eeb56f1f971a1babd2.png" /></p>
<p>图2.功能模块图</p>
<h3 id="3-2-3模型设计">3.2.3模型设计</h3>
<p>根据需求分析，可以设计以下数据库表：</p>
<p>用户表(user)，博客表(blog)，博客分类表(category)，留言（message），评论（comment），收藏（collection），点赞（like），搜索记录表（search）</p>
<p>，推荐表（recommend），友链（friendlink），文件表（file），请求记录表（request record），用户操作记录表（action），错误记录表（error），它们之间的关系如下图所示：</p>
<p><img src="../../../media/image/2023/06/12/image.7216283608df11eeb56f1f971a1babd2.png" alt="image.7216283608df11eeb56f1f971a1babd2.png" /></p>
<p>图3.模型的ER图</p>
<h2 id="3-3-使用Django框架实现博客系统">3.3 使用Django框架实现博客系统</h2>
<h3 id="3-3-1用户相关">3.3.1用户相关</h3>
<h4 id="3-3-1-1注册"><strong>3.3.1.1注册</strong></h4>
<p>用户可以通过手机号注册一个账号。注册后可以使用登录功能登录网站，在登录成功后，能够使用发布博客，点赞，评论，留言等功能，同时对于登录的用户，可以更精确地对用户行为进行记录，从而为用户提供更好的个性化服务。</p>
<p><strong>实现过程</strong></p>
<p>在访问注册页面后（此时使用get方法），首先会获取一个表单，用户通过表单输入相关信息，点击“注册”按钮，前端会进行输入合法性的校验，在校验通过后，会通过Ajax将表单信息以post的方法异步传输给后端；来到后端后，首先通过request对象获取传输的信息，之后还会做一系列的检查（包含：手机号格式检查，手机号重复检查，验证码过期检查，验证码正确性检查等），虽然其中的一些检查在前端已经校验过，但是在实际生活中危险是无处不在的，除了一般的用户会使用浏览器正常进行访问，一些技术相关的人员可能会通过特定的工具进行访问，所以为了防止接口的恶意攻击，提高服务的安全性是非常有必要的。</p>
<p><img src="../../../media/image/2023/06/12/image.86f8b03408df11eeb56f1f971a1babd2.png" alt="image.86f8b03408df11eeb56f1f971a1babd2.png" /></p>
<p>图4.注册流程</p>
<h4 id="3-3-1-2登录"><strong>3.3.1.2登录</strong></h4>
<p>用户可以使用注册时提供的用户名和密码登录网站。登录后可以享受更多的功能，例如评论、点赞、收藏、博客编辑等。</p>
<p><strong>实现过程</strong></p>
<p>在访问登录页面后（同样使用的是get方法），用户会获取到表单页面，输入相应的表单信息，点击“登录”即可，请求来到后端后，会检查用户名是否存在以及密码的正确性，如果检查不通过会响应相应的提示给前端，检查通过后会使用django内置的login方法实现用户的登录。使用django内置的登录功能的主要原因有两点：</p>
<ol>
<li>便利性</li>
</ol>
<p>使用django内置的login，不需要自己额外去保存相关的信息，比如缓存，登录状态等，并且可以直接使用。</p>
<ol start="2">
<li>兼容性</li>
</ol>
<p>由于用户表是直接继承自django内置的User模型，所以用户相关的操作也必须使用django内置的，否则相关功能不会生效；</p>
<h4 id="3-1-1-3更新密码"><strong>3.1.1.3更新密码</strong></h4>
<p>用户可以通过提供注册时使用手机号码来重置密码。这是当用户忘记密码时，能够重新设置密码的方法（注意：密码重置功能每天仅限3次）。</p>
<p><strong>实现过程</strong></p>
<p>继承（Inheritance）是面向对象编程中的一个重要概念，它指的是一个对象（称为子类或派生类）从另一个对象（称为父类或基类）那里继承了一部分属性和方法，从而可以直接使用这些属性和方法，而不必重新定义。继承的关系可以理解为“is-a”的关系，即子类是父类的一种特殊情况。除了python语言自带的“继承”这个概念，在django的模板中，也同样有继承这个概念，对比“注册”（参考下图左）和“更新密码”（参考下图右）所需要的参数信息，可以发现基本上是一样的，但是为了区别“注册”功能，在“更新密码”功能中额外加入一个标识参数进行标识即可；因此“更新密码”的模板直接继承自“更新密码”注册的模板即可。</p>
<p><img src="../../../media/image/2023/06/12/image.8e67768e08df11eeb56f1f971a1babd2.png" alt="image.8e67768e08df11eeb56f1f971a1babd2.png" /><img src="../../../media/image/2023/06/12/image.94231ed408df11eeb56f1f971a1babd2.png" alt="image.94231ed408df11eeb56f1f971a1babd2.png" /></p>
<p>图5.注册（左）                      图6.更新密码（右）</p>
<p>后端的业务逻辑也同样使用“注册”的接口，只不过需要根据标识参数的值来执行不同的业务逻辑。</p>
<h3 id="3-3-2博客相关">3.3.2博客相关</h3>
<h4 id="3-3-2-1博客列表"><strong>3.3.2.1博客列表</strong></h4>
<p>用户可以查看所有的博客文章列表，列表会根据用户的操作历史记录，博客的热度和发布日期等因素计算出的得分进行排序，从而为用户推荐感兴趣，质量高，且新鲜的博客。</p>
<p><strong>实现过程</strong></p>
<p>博客列表的实现可以大致分为三部分：1.获取所有博客对象，2.计算推荐度，3.分页。</p>
<p>其中步骤2就是应用协同过滤推荐算法到博客系统的具体步骤，因此，在应用之前，一个简单的博客系统只需要步骤1和步骤3即可，由于协同过滤算法会在下面进行详细的讲解，所以这里就对步骤1和步骤3进行讲解。</p>
<p>步骤1的实现非常简单，直接通过“Blog模型“实例对象调用相应的接口即可获取查询集，我这里用到的是only接口，映射到sql语句时，就是只查询需要的字段，而不是通过“*”匹配所有的字段，这样在一定程度上提高了查询效率。</p>
<p><img src="../../../media/image/2023/06/12/image.9e6d202408df11eeb56f1f971a1babd2.png" alt="image.9e6d202408df11eeb56f1f971a1babd2.png" /></p>
<p>图7.博客列表的only查询语句</p>
<p>步骤3的实现则使用到了django内置的Paginator对象，将步骤1中得到的所有博客对象以及每页的数量作为参数传给Paginator对象，就会生成相应的页面对象，从而达到分页的效果。</p>
<h4 id="3-3-2-2博客详情"><strong>3.3.2.2博客详情</strong></h4>
<p>用户可以查看单篇博客的详情内容，并进行点赞、收藏、评论等操作。这个功能可以让用户更深入地了解某个主题或文章。</p>
<p><strong>实现过程</strong></p>
<p>在博客详情页面中，以内容的展示为核心功能。通过博客的id可以找到指定的博客对象，因此每一篇博客都唯一对应一个页面。用户在请求一个博客的详情页面后，后端会首先判断用户的登录状态，从而获取“收藏”，“点赞”的状态，同时判断对当前博客的编辑权限；之后会统计当前的博客的访问量（包含pv，uv，dpv，duv），以及记录当前用户的访问记录，最后将内容返回给前端。</p>
<p>来到前端页面后，页面的大体布局如下图所示：顶部为导航栏，左下为博客内容，右下为功能页。由于在开发过程中一直使用的是pc端进行开发，没有考虑到移动端（显示宽度较小的设备），因此在使用移动设备进行查看时，页面内容会显示异常。</p>
<p><img src="../../../media/image/2023/06/12/image.a6a9453808df11eeb56f1f971a1babd2.png" alt="image.a6a9453808df11eeb56f1f971a1babd2.png" /></p>
<p>图8.《关于》博客详情页面-PC端展示</p>
<p>为了解决移动端和PC端的适配问题，后来用到了bootstrap的栅格系统和JavaScript中的事件监听方法。</p>
<p>栅格系统（Grid System）：Bootstrap的栅格系统是一种响应式的布局方式，将页面分成12个等宽的列，可以根据需要将页面划分为不同数量的列，实现不同的布局效果。栅格系统提供了多种列宽度的选项，可以通过添加CSS类名来实现。</p>
<p>JavaScript中的事件监听（Event Listening）指的是在页面元素上注册事件处理程序（Event Handler），当该页面元素上发生特定的事件时，事件处理程序就会被调用，从而实现对事件的响应。事件监听是实现JavaScript交互性和动态效果的重要方式。在JavaScript中，可以使用addEventListener()方法或者DOM元素属性来添加事件监听器^[6]^。</p>
<p>有了这两个方法后，就可以根据访问设备的显示宽度进行分开显示，当显示宽度大于1000px时，页面内容进行“3-1”的划分，博客内容占用9列，功能页占用3列；当页面宽度小于1000px时，页面只显示博客内容，将功能页进行隐藏，然后使用JavaScript的事件监听，将监听窗口的加载（load）和重置大小（resize）方法注册到window对象上，将上面的逻辑添加到EventHandler即可，如下：移动端正常显示博客内容。</p>
<p><img src="../../../media/image/2023/06/12/image.af1018b408df11eeb56f1f971a1babd2.png" alt="image.af1018b408df11eeb56f1f971a1babd2.png" /></p>
<p>图9.《关于》博客详情页面-移动端展示</p>
<h4 id="3-3-2-3博客编辑"><strong>3.3.2.3博客编辑</strong></h4>
<p>博客作者可以通过编辑页面对已有的博客进行修改或删除，也可以新增博客。这个功能可以让博客作者更方便地管理和更新自己的博客。</p>
<p><strong>实现过程</strong></p>
<p>博客编辑的功能实现可以分为两部分：1.请求编辑页面，2.保存博客数据。</p>
<p>当用户使用的是GET请求时，返回博客编辑页面，需要注意的是，因为博客需要关联到作者，因此必须要求用户登录后才能使用此功能，为了减小开发和维护的成本，使用装饰器实现了登录监测功能。</p>
<p>装饰器（Decorator）是一种用于修改类、函数、方法或属性的语法特性。装饰器可以在不修改类或函数源代码的情况下，为其添加新的功能或修改原有功能。在多数情况下，一段代码可能关联很多模块，但是为了开发新的功能需要对其进行修改，此时如果直接修改可能需要很大的时间和人力成本，那么装饰器就是很好的选择，这是选择装饰器的原因之一；当很多接口都有相同的逻辑，如果每一个接口都去重复编写这段逻辑，不仅编写起来耗时，维护起来也会更加的耗时，因此如果将这些相同的逻辑封装并打包成一个装饰器，最后装饰在每一个接口上，那么可以大大减少开发成本和维护成本，这是选择装饰器的原因之二，也是我在本次博客系统中选择装饰器实现登录检测功能的原因，考虑到多个接口：编辑博客，点赞，收藏，评论等接口几乎都需要进行登录状态的检查，因此将其封装成一个装饰器之后装饰这些接口很大程度上减少了我开发和维护的成本，具体代码逻辑如下：</p>
<pre><code class="language-python">def require_login(require_self=False):
    def outer(func):
        def inner(*args, **kwargs):
            # 根据第一个参数是否是视图函数的实例来取self和request的值
            if isinstance(args[0], View):
                self = args[0]
                request = args[1]
            else:
                request = args[0]
            if not request.user.is_authenticated:
                return JsonResponse({
                    &#39;code&#39;: &#39;400&#39;,
                    &#39;msg&#39;: &#39;请先登录!&#39;
                })
            if require_self:
                tmp_user_id = request.data.get(&#39;user&#39;) or request.POST.get(&#39;user&#39;) or request.GET.get(&#39;user&#39;)
                if str(request.user.id) != tmp_user_id:
                    return JsonResponse({
                        &#39;code&#39;: &#39;400&#39;,
                        &#39;msg&#39;: &#39;非本人操作!&#39;
                    })
            try:
                res = func(*args, **kwargs)
            except Exception as e:
                print(e)
                return None
            return res
        return inner
    return outer
<p>span</p>
<p>code</p>
<p>code</p>
<h1 id="code">code</h1>
<p>code</p>
<p>code</p>
<p>code</p>
<p>code</p>
<p>code</p>
<p>code</p>
<p>code</p>
<p>code</p>
<p>code</p>
<p>code</p>

