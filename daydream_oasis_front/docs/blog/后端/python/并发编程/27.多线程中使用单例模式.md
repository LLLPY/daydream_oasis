
<BlogInfo id="839" title="27.多线程中使用单例模式" author="白日梦想猿" pv=0 read_times=0 pre_cost_time=0分36秒 category="并发编程" tag_list="['并发编程']" create_time="2022.03.03 17:28:29" update_time="2022.03.03 17:34:20" />

```python
from concurrent.futures import ThreadPoolExecutor
from threading import RLock


class Singleton:
    instance = None
    lock=RLock()

    def __init__(self):
        pass

    def __new__(cls, *args, **kwargs):
        # 在创建一个新的对象时，首先判断有没有已经存在的对象
        # 如果没有存在的对象就创建一个新的对象
        # 这样就保证了所有的对象使用的都是同一个地址
        with cls.lock:
            if not cls.instance:
                cls.instance = object.__new__(cls)

            return cls.instance


def task():
    obj=Singleton()
    # print(obj)
    return obj



if __name__ == '__main__':
    pool=ThreadPoolExecutor(100)

    fur_list=[]
    for i in range(100):
        fur=pool.submit(task)
        fur_list.append(fur)

    for fur in fur_list:
        print(fur.result())

```
