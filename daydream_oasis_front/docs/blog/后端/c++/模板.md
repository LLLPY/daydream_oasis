---

next: false

---



<BlogInfo id="373"/>

# 模板

## 7.1模板的概念

在强类型程序设计语言中,参与运算的所有对象的类型在编译时即可确定下来,并且编译程序将进行严格的类型检测,这样可以在程序未运行之前就检查出类型不兼容的错误,帮助程序员开发可靠性较高的程序.

但这种强类型语言在提高可靠性的同时又带来了一些副作用,例如,以下两个函数:
```c++

    

    int max(int a,int b){

        return a>b?a:b;

    }

    ​

    和

     float max(float a,float b){

        return a>b?a:b;

    }
```


一个是求两个整数中的较大值,另一个是求两个浮点数中的较大值.它们采用的算法基本基本完全一样,但由于参数类型不同,程序员只好写两段几乎完全相同的代码.

## 7.2解决强类型冲突的几种途径

  1. 利用红宏函数,众所周知,宏函数虽然方便,但是有时常常会引入一些意想不到的问题,从c++开始已经不提倡使用宏了;
  2. 为各种类型都重载这一函数,而为各种数据类型重载又显得有点麻烦
  3. 放松类型检测,在编译期间忽略这些类型匹配问题,而在运行期间进行类型匹配检测,但在程序运行时可能出现类型不兼容的问题
  4. 最理想的方法,是直接将数据类型作为参数,就像函数可以将数据作为参数一样,这种机制被称为类属.

在c++语言中,程序员可以采用模板(template)机制实现类属.类属机制既提供了数据类型的灵活性,也支持在编译时做严格的类型检测,因而被认为是提高程序可重用性的有力工具.

模板是一种参数化的多态性工具,可以为逻辑功能相同而类型不同的程序提供代码共享机制.

由于c++程序结构主要构件是类和函数.所以在c++中,模板卑分为函数模板和类模板.模板并非一个实实在在的防暑或类,仅仅是函数或类的描述,模板运算对象的类型不是实际的数据类型,而是一种参数化的类型(又称为类属类型).类属参数的函数称为函数模板,类属参数的类称为模板类.程序员只需要面对抽象的类属类型编写逻辑操作代码,而无需关心实际运行时的数据类型.

## 7.3函数模板

函数模板的定义格式如下:
```c++

    

    template <模板参数表>

    <返回值类型><函数名>(<参数表>){

    <函数体>

    }
```


其中,关键字template说定义模板的关键字.<模板参数表>中包含一个或多个用逗号分开的模板参数项,每一项由保留字class或者typename开始,后跟用户命名的标识符,此标识符为模板参数,表示数据类型.函数模板中可以利用这些模板参数定义函数返回值类型,参数类型和函数体中的变量类型.它同基本数据类型一样,可以在函数中任何地方使用.



例7.3.定义函数模板求两个数中的较大值
```c++

    

    template 

    T max(T a,T b){    

        return a>b?a:b

    }
```


当程序中使用这个函数模板时,编译程序将根据函数调用时的实际数据类型产生相应的函数.如产生求两个整数中的较大值函数,或求两个浮点数中较大值函数.

<参数表>中可以使用模板参数,也可以使用一般类型参数.但<参数表>至少有一个形参的类型必须用<模板参数表>中的参数定义的,并且在<模板参数表>中的每个模板参数都必须在<参数表>中得到使用,即作为形参的类型使用.

## 7.4利用例7.3中的函数模板求两个数中的较大值
```c++

    

    #include

    using namespace std;

    ​

    template  //函数模板

    T max(T a,T b){

        return a>b?a:b;

    }

    ​

    int main(){

        

        int a=19,b=23,c;

        c=max(a,b);

        cout<    

        

        

        

        return 0;

    }

    ​

    ​

    ​

    ​

    ​
```








程序运行结果如下:

![](http://www.lll.plus/media/image/2021/06/28/模板1624860714.5890150.png)



.









<ActionBox />
