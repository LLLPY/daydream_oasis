---
sidebar: false
next: false
---
<BlogInfo/>

# 题目

> ## 描述
> 
> 一个机器人在m×n大小的地图的左上角（起点）。
> 
> 机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。
> 
> 可以有多少种不同的路径从起点走到终点？
> 
> ![](http://www.lll.plus/media/image/2024/01/18/92e6555f3ab3e9e54fc0de4cc08227f1.a305d376b55811eeb3a9eb54e8a036ec.jpg)
> 
> 备注：m和n小于等于100,并保证计算结果在int范围内
> 
> 数据范围：0 < n,m le 1000<n,m≤100，保证计算结果在32位整型范围内
> 
> 要求：空间复杂度 O(nm)O(nm)，时间复杂度 O(nm)O(nm)
> 
> 进阶：空间复杂度 O(1)O(1)，时间复杂度 O(min(n,m))O(min(n,m))
> 
> ## 示例1
> 
> 输入：
> 
> ```
> 2,1
> ```
> 
> 复制返回值：
> 
> ```
> 1
> ```
> 
> 复制
> 
> ## 示例2
> 
> 输入：
> 
> ```
> 2,2
> ```
> 
> 复制返回值：
> 
> ```
> 2
> ```
> 
> 复制

# 思路

](http://www.lll.plus/media/image/2024/01/18/8b95b7589d0557073036327999764a62.a33d7d4eb55811eeb3a9eb54e8a036ec.jpg)

# 源码

```python
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param m int整型 
# @param n int整型 
# @return int整型
#
class Solution:
    #__slots__=()
    def uniquePaths(self , m: int, n: int) -> int:
        # write code here
        '''
        动态规划：由题意知：当前位置可由左边和上边过来，因此
        我们可以建立一个二维的dp数组，用来从起点到当前位置的
        路径条数
        则：
            dp[i][j]=dp[i-1][j]+dp[i][j-1] (i>=1 j>=1)
        '''
        #第一行第一列所有的值都为1，所以可以直接初始化所有的值都为1
        dp=[[1 for j in range(n)] for i in range(m)]
        #m行 n列
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j]=dp[i-1][j]+dp[i][j-1]
        return dp[-1][-1]
```

# 通过截图

![](http://www.lll.plus/media/image/2024/01/15/3b03a783f24e4e84b0e78c8ea660695c.62baa376b2f811eeb3a9eb54e8a036ec.png)

<ActionBox />
        
<style>#top-box {margin-top:0.5rem!important;}</style>